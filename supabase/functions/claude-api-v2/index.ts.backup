// Copyright Mark Skiba, 2025 All rights reserved
// Claude API Edge Function v2 - Hybrid Architecture
// Handles Claude API calls with client callback system

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';
import Anthropic from 'https://esm.sh/@anthropic-ai/sdk@0.29.0';

// Types for the hybrid architecture
interface EdgeFunctionCall {
  functionName: string;
  parameters: any;
  clientCallbacks?: ClientCallback[];
  sessionContext?: {
    sessionId: string;
    timestamp: string;
  };
}

interface ClientCallback {
  type: 'ui_refresh' | 'state_update' | 'notification';
  target: string;
  payload: any;
}

interface EdgeFunctionResponse {
  success: boolean;
  data: any;
  clientCallbacks?: ClientCallback[];
  requiresClientAction?: boolean;
  message?: string;
}

// Initialize Supabase client
const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
const supabase = createClient(supabaseUrl, supabaseServiceKey);

// Initialize Anthropic client with server-side API key
const anthropicApiKey = Deno.env.get('ANTHROPIC_API_KEY') || Deno.env.get('CLAUDE_API_KEY');
if (!anthropicApiKey) {
  throw new Error('ANTHROPIC_API_KEY or CLAUDE_API_KEY environment variable is required');
}

const anthropic = new Anthropic({
  apiKey: anthropicApiKey,
});

// Authentication helper
async function getUserFromAuth(authHeader: string | null): Promise<{ user: any; profile: any } | null> {
  if (!authHeader?.startsWith('Bearer ')) {
    return null;
  }

  const token = authHeader.substring(7);
  const { data: { user }, error: userError } = await supabase.auth.getUser(token);
  
  if (userError || !user) {
    console.error('Auth error:', userError);
    return null;
  }

  // Get user profile
  const { data: profile } = await supabase
    .from('user_profiles')
    .select('*')
    .eq('supabase_user_id', user.id)
    .single();

  return { user, profile };
}

// Claude API Functions
class ClaudeAPIHandler {
  
  // Non-streaming Claude API call
  async generateMessage(params: {
    messages: any[];
    model?: string;
    max_tokens?: number;
    temperature?: number;
    system?: string;
    tools?: any[];
  }): Promise<any> {
    console.log('ü§ñ Generating non-streaming Claude response');
    
    try {
      const response = await anthropic.messages.create({
        model: params.model || 'claude-3-5-sonnet-20241022',
        max_tokens: params.max_tokens || 4000,
        temperature: params.temperature || 0.7,
        system: params.system,
        messages: params.messages,
        tools: params.tools,
      });

      console.log('‚úÖ Claude API response received');
      return {
        success: true,
        data: response,
        usage: response.usage,
        model: response.model,
      };
    } catch (error) {
      console.error('‚ùå Claude API error:', error);
      throw new Error(`Claude API error: ${error.message}`);
    }
  }

  // Generate streaming Claude response using Server-Sent Events
  async generateStreamingResponse(params: {
    model?: string;
    max_tokens?: number;
    temperature?: number;
    system?: string;
    messages: any[];
    tools?: any[];
    sessionContext?: any;
    userId?: string;
  }): Promise<ReadableStream> {
    console.log('üåä Generating streaming Claude response');
    
    const stream = new ReadableStream({
      start(controller) {
        (async () => {
          try {
            const stream = await anthropic.messages.create({
              model: params.model || 'claude-3-5-sonnet-20241022',
              max_tokens: params.max_tokens || 4000,
              temperature: params.temperature || 0.7,
              system: params.system,
              messages: params.messages,
              tools: params.tools,
              stream: true,
            });

            console.log('üåä Claude streaming response initiated');

            let fullContent = '';
            let tokenCount = 0;
            let currentToolUse: any = null;
            let toolResults: any[] = [];
            let toolsExecuted = false;
            let contentBlocksFinished = 0;
            let totalContentBlocks = 0;

            for await (const messageStreamEvent of stream) {
              try {
                if (messageStreamEvent.type === 'message_start') {
                  // Send initial metadata
                  const sseData = JSON.stringify({
                    type: 'start',
                    model: messageStreamEvent.message.model,
                    usage: messageStreamEvent.message.usage,
                  });
                  const encoder = new TextEncoder();
                  controller.enqueue(encoder.encode(`data: ${sseData}\n\n`));
                  
                } else if (messageStreamEvent.type === 'content_block_start') {
                  totalContentBlocks++;
                  if (messageStreamEvent.content_block?.type === 'tool_use') {
                    currentToolUse = {
                      id: messageStreamEvent.content_block.id,
                      name: messageStreamEvent.content_block.name,
                      input: {},
                    };
                  }
                  
                } else if (messageStreamEvent.type === 'content_block_delta') {
                  if (messageStreamEvent.delta?.type === 'text_delta') {
                    const textChunk = messageStreamEvent.delta.text;
                    fullContent += textChunk;
                    tokenCount++;
                    
                    // Send text chunk
                    const sseData = JSON.stringify({
                      type: 'content_delta',
                      delta: textChunk,
                      full_content: fullContent,
                      token_count: tokenCount,
                    });
                    const encoder = new TextEncoder();
                    controller.enqueue(encoder.encode(`data: ${sseData}\n\n`));
                    
                  } else if (messageStreamEvent.delta?.type === 'input_json_delta') {
                    if (currentToolUse) {
                      // Accumulate tool input
                      try {
                        const partialInput = messageStreamEvent.delta.partial_json;
                        currentToolUse.partial_input = (currentToolUse.partial_input || '') + partialInput;
                      } catch (e) {
                        console.warn('Tool input parsing issue:', e);
                      }
                    }
                  }
                  
                } else if (messageStreamEvent.type === 'content_block_stop') {
                  contentBlocksFinished++;
                  
                  if (currentToolUse) {
                    try {
                      currentToolUse.input = JSON.parse(currentToolUse.partial_input || '{}');
                      delete currentToolUse.partial_input;
                      
                      // Send tool use event
                      const sseData = JSON.stringify({
                        type: 'tool_use',
                        tool_use: currentToolUse,
                      });
                      const encoder = new TextEncoder();
                      controller.enqueue(encoder.encode(`data: ${sseData}\n\n`));
                      
                      // Execute tool function (if available)
                      console.log(`üîß DEBUG - Executing tool in streaming context: ${currentToolUse.name}`);
                      
                      try {
                        // Execute the tool using our handleFunction system
                        const toolResult = await handleFunction({
                          functionName: currentToolUse.name,
                          parameters: currentToolUse.input,
                          sessionContext: params.sessionContext
                        }, params.userId || 'anonymous'); // Use the actual authenticated user ID
                        
                        console.log(`‚úÖ DEBUG - Tool execution result:`, {
                          functionName: currentToolUse.name,
                          success: toolResult.success,
                          hasCallbacks: toolResult.clientCallbacks && toolResult.clientCallbacks.length > 0
                        });
                        
                        toolResults.push({
                          tool_call_id: currentToolUse.id,
                          tool_name: currentToolUse.name,
                          tool_input: currentToolUse.input,
                          result: toolResult
                        });
                        
                        // Send tool result through streaming
                        const toolResultData = JSON.stringify({
                          type: 'tool_result',
                          tool_call_id: currentToolUse.id,
                          result: toolResult,
                        });
                        controller.enqueue(encoder.encode(`data: ${toolResultData}\n\n`));
                        
                        // If there are client callbacks, send them through streaming
                        if (toolResult.clientCallbacks && toolResult.clientCallbacks.length > 0) {
                          console.log(`üì§ DEBUG - Sending ${toolResult.clientCallbacks.length} callbacks through streaming`);
                          
                          const callbackData = JSON.stringify({
                            type: 'client_callbacks',
                            callbacks: toolResult.clientCallbacks,
                          });
                          controller.enqueue(encoder.encode(`data: ${callbackData}\n\n`));
                        }
                        
                        toolsExecuted = true;
                        
                      } catch (toolError) {
                        console.error(`‚ùå Tool execution error for ${currentToolUse.name}:`, toolError);
                        
                        const errorMessage = toolError instanceof Error ? toolError.message : String(toolError);
                        toolResults.push({
                          tool_call_id: currentToolUse.id,
                          tool_name: currentToolUse.name,
                          tool_input: currentToolUse.input,
                          error: errorMessage
                        });
                        
                        // Send tool error through streaming
                        const toolErrorData = JSON.stringify({
                          type: 'tool_error',
                          tool_call_id: currentToolUse.id,
                          error: errorMessage,
                        });
                        controller.enqueue(encoder.encode(`data: ${toolErrorData}\n\n`));
                        
                        toolsExecuted = true;
                      }
                      
                    } catch (e) {
                      console.error('Tool use parsing error:', e);
                    }
                    currentToolUse = null;
                  }

                  // Check if all content blocks are finished
                  if (contentBlocksFinished >= totalContentBlocks) {
                    console.log(`üîç All content blocks finished: ${contentBlocksFinished}/${totalContentBlocks}, toolsExecuted: ${toolsExecuted}, toolResults: ${toolResults.length}`);
                    
                    // If tools were executed, send tool results directly as completion
                    if (toolsExecuted && toolResults.length > 0) {
                      console.log('ÔøΩ DEBUG - Tools executed, tool results:', JSON.stringify(toolResults, null, 2));
                      
                      // Create tool result messages for Claude continuation
                      const toolResultMessages = toolResults.map(tr => ({
                        type: 'tool_result',
                        tool_use_id: tr.tool_call_id,
                        content: tr.error ? 
                          `Error: ${tr.error}` : 
                          typeof (tr.result.data || tr.result) === 'object' ?
                          JSON.stringify(tr.result.data || tr.result, null, 2) :
                          String(tr.result.data || tr.result)
                      }));
                      
                      // Add tool results to the conversation and continue with Claude
                      const continuationMessages = [
                        ...params.messages,
                        {
                          role: 'assistant',
                          content: [
                            { type: 'text', text: fullContent },
                            ...toolResults.map(tr => ({
                              type: 'tool_use',
                              id: tr.tool_call_id,
                              name: tr.tool_name,
                              input: tr.tool_input
                            }))
                          ]
                        },
                        {
                          role: 'user',
                          content: toolResultMessages
                        }
                      ];
                      
                      console.log('üîÑ Starting continuation stream with tool results');
                      
                      try {
                        // Start a new streaming request with tool results
                        const continuationStream = await anthropic.messages.create({
                          model: params.model || 'claude-3-5-sonnet-20241022',
                          max_tokens: params.max_tokens || 4000,
                          temperature: params.temperature || 0.7,
                          system: params.system,
                          messages: continuationMessages,
                          tools: params.tools,
                          stream: true,
                        });
                        
                        // Process continuation stream
                        for await (const continuationEvent of continuationStream) {
                          if (continuationEvent.type === 'content_block_delta' && 
                              continuationEvent.delta?.type === 'text_delta') {
                            const textChunk = continuationEvent.delta.text;
                            fullContent += textChunk;
                            tokenCount++;
                            
                            console.log(`üìù CONTINUATION DEBUG - Text chunk: "${textChunk}", Full content length: ${fullContent.length}`);
                            
                            // Send continuation text chunk
                            const sseData = JSON.stringify({
                              type: 'content_delta',
                              delta: textChunk,
                              full_content: fullContent,
                              token_count: tokenCount,
                            });
                            const encoder = new TextEncoder();
                            controller.enqueue(encoder.encode(`data: ${sseData}\n\n`));
                            
                          } else if (continuationEvent.type === 'message_stop') {
                            console.log(`‚úÖ Continuation stream completed - Final content length: ${fullContent.length}`);
                            console.log(`üìù CONTINUATION DEBUG - Final full content: "${fullContent}"`);
                            
                            // Send final completion
                            const sseData = JSON.stringify({
                              type: 'complete',
                              full_content: fullContent,
                              token_count: tokenCount,
                              tool_results: toolResults,
                            });
                            const encoder = new TextEncoder();
                            controller.enqueue(encoder.encode(`data: ${sseData}\n\n`));
                            
                            console.log('‚úÖ Claude streaming response completed with tool continuation');
                            
                            controller.close();
                            return;
                          }
                        }
                      } catch (continuationError) {
                        console.error('‚ùå Continuation stream error:', continuationError);
                        
                        // Fall back to sending tool results as completion
                        const fallbackSummary = toolResults.map(tr => {
                          const result = tr.error ? `Error: ${tr.error}` : JSON.stringify(tr.result.data || tr.result, null, 2);
                          return `${tr.tool_name}: ${result}`;
                        }).join('\n\n');
                        
                        const sseData = JSON.stringify({
                          type: 'complete',
                          full_content: fullContent + '\n\nTool Results:\n' + fallbackSummary,
                          token_count: tokenCount,
                          tool_results: toolResults,
                        });
                        const encoder = new TextEncoder();
                        controller.enqueue(encoder.encode(`data: ${sseData}\n\n`));
                        
                        console.log('‚úÖ Claude streaming response completed with fallback tool results');
                        
                        controller.close();
                      }
                      
                      return; // Exit after continuation is complete
                    }
                    
                    // If no tools were executed, we're done
                    if (!toolsExecuted || toolResults.length === 0) {
                      console.log('üèÅ All content blocks completed - sending completion');
                      
                      // Send completion event
                      const sseData = JSON.stringify({
                        type: 'complete',
                        full_content: fullContent,
                        token_count: tokenCount,
                        tool_results: toolResults,
                      });
                      const encoder = new TextEncoder();
                      controller.enqueue(encoder.encode(`data: ${sseData}\n\n`));
                      
                      console.log('‚úÖ Claude streaming response completed (all content blocks finished)');
                      
                      controller.close();
                      return;
                    }
                  }
                  
                } else if (messageStreamEvent.type === 'message_delta') {
                  // Update usage stats
                  if (messageStreamEvent.usage) {
                    const sseData = JSON.stringify({
                      type: 'usage_update',
                      usage: messageStreamEvent.usage,
                    });
                    const encoder = new TextEncoder();
                    controller.enqueue(encoder.encode(`data: ${sseData}\n\n`));
                  }
                  
                } else if (messageStreamEvent.type === 'message_stop') {
                  console.log(`üõë Message stop event - toolsExecuted: ${toolsExecuted}, toolResults: ${toolResults.length}`);
                  
                  // Don't complete here if tools were executed - let content_block_stop handle continuation
                  if (toolsExecuted && toolResults.length > 0) {
                    console.log('üîÑ Message stopped but tools executed - content_block_stop will handle completion');
                    return;
                  }
                  
                  // Only complete if no tools were executed
                  const sseData = JSON.stringify({
                    type: 'complete',
                    full_content: fullContent,
                    token_count: tokenCount,
                    tool_results: toolResults,
                  });
                  const encoder = new TextEncoder();
                  controller.enqueue(encoder.encode(`data: ${sseData}\n\n`));
                  
                  console.log('‚úÖ Claude streaming response completed (no tools)');
                  
                  controller.close();
                  return;
                }
              } catch (chunkError) {
                console.error('‚ùå Error processing stream chunk:', chunkError);
                const errorMessage = chunkError instanceof Error ? chunkError.message : 'Stream processing error';
                const errorData = JSON.stringify({
                  type: 'error',
                  error: errorMessage,
                });
                const encoder = new TextEncoder();
                controller.enqueue(encoder.encode(`data: ${errorData}\n\n`));
              }
            }

          } catch (error) {
            console.error('‚ùå Claude streaming error:', error);
            const errorMessage = error instanceof Error ? error.message : 'Streaming error';
            const errorData = JSON.stringify({
              type: 'error',
              error: errorMessage,
            });
            const encoder = new TextEncoder();
            controller.enqueue(encoder.encode(`data: ${errorData}\n\n`));
            controller.close();
          }
        })();
      },
      
      cancel() {
        console.log('üõë Claude streaming cancelled');
      }
    });

    return stream;
  }

  // Test Claude API connection
  async testConnection(): Promise<any> {
    console.log('üîç Testing Claude API connection');
    
    try {
      const response = await anthropic.messages.create({
        model: 'claude-3-5-sonnet-20241022',
        max_tokens: 50,
        messages: [{ role: 'user', content: 'Hello, please respond with "Connection successful"' }],
      });

      return {
        success: true,
        data: {
          message: 'Claude API connection successful',
          model: response.model,
          response: response.content[0]?.text || 'No response text',
        },
      };
    } catch (error) {
      console.error('‚ùå Claude API connection test failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
        data: null,
      };
    }
  }
}

// Database operations handler
class DatabaseHandler {
  
  async supabaseSelect(params: any, userId: string): Promise<any> {
    const { table, columns = '*', filter, limit, order } = params;
    
    console.log('üîç Supabase SELECT:', { table, columns, filter, limit, order, userId });
    
    if (!table) {
      throw new Error('Table name is required for supabase_select');
    }
    
    try {
      let query = supabase.from(table).select(columns);
      
      // Apply filter if provided
      if (filter && filter.field && filter.operator && filter.value !== undefined) {
        const { field, operator, value } = filter;
        
        switch (operator) {
          case 'eq':
            query = query.eq(field, value);
            break;
          case 'neq':
            query = query.neq(field, value);
            break;
          case 'gt':
            query = query.gt(field, value);
            break;
          case 'lt':
            query = query.lt(field, value);
            break;
          case 'gte':
            query = query.gte(field, value);
            break;
          case 'lte':
            query = query.lte(field, value);
            break;
          case 'like':
            query = query.like(field, value);
            break;
          case 'in':
            if (Array.isArray(value)) {
              query = query.in(field, value);
            } else {
              throw new Error('Value must be an array when using "in" operator');
            }
            break;
          default:
            throw new Error(`Unsupported operator: ${operator}`);
        }
      }
      
      // Apply ordering if provided
      if (order && order.field) {
        query = query.order(order.field, { ascending: order.ascending !== false });
      }
      
      // Apply limit if provided
      if (limit && typeof limit === 'number' && limit > 0) {
        query = query.limit(limit);
      }
      
      const { data, error } = await query;
      
      if (error) {
        console.error('‚ùå Supabase SELECT error:', error);
        throw new Error(`Failed to select from ${table}: ${error.message}`);
      }
      
      console.log('‚úÖ Supabase SELECT success:', { table, rowCount: data?.length || 0 });
      
      return {
        table,
        data: data || [],
        count: data?.length || 0
      };
    } catch (error) {
      console.error('‚ùå Supabase SELECT exception:', error);
      throw error;
    }
  }

  async supabaseInsert(params: any, userId: string): Promise<any> {
    const { table, data, returning = '*' } = params;
    
    console.log('üìù Supabase INSERT:', { table, data, returning, userId });
    
    if (!table) {
      throw new Error('Table name is required for supabase_insert');
    }
    
    if (!data || typeof data !== 'object') {
      throw new Error('Data object is required for supabase_insert');
    }
    
    try {
      const result = await supabase
        .from(table)
        .insert(data)
        .select(returning);
        
      const { data: insertedData, error } = result;
      
      if (error) {
        console.error('‚ùå Supabase INSERT error:', error);
        throw new Error(`Failed to insert into ${table}: ${error.message}`);
      }
      
      console.log('‚úÖ Supabase INSERT success:', { table, rowCount: insertedData?.length || 0 });
      
      return {
        table,
        data: insertedData || [],
        count: insertedData?.length || 0
      };
    } catch (error) {
      console.error('‚ùå Supabase INSERT exception:', error);
      throw error;
    }
  }

  async supabaseUpdate(params: any, userId: string): Promise<any> {
    const { table, data, filter, returning = '*' } = params;
    
    console.log('‚úèÔ∏è Supabase UPDATE:', { table, data, filter, returning, userId });
    
    if (!table) {
      throw new Error('Table name is required for supabase_update');
    }
    
    if (!data || typeof data !== 'object') {
      throw new Error('Data object is required for supabase_update');
    }
    
    if (!filter || !filter.field || !filter.operator || filter.value === undefined) {
      throw new Error('Filter with field, operator, and value is required for supabase_update');
    }
    
    try {
      let query = supabase.from(table).update(data);
      
      // Apply filter
      const { field, operator, value } = filter;
      
      switch (operator) {
        case 'eq':
          query = query.eq(field, value);
          break;
        case 'neq':
          query = query.neq(field, value);
          break;
        case 'gt':
          query = query.gt(field, value);
          break;
        case 'lt':
          query = query.lt(field, value);
          break;
        case 'gte':
          query = query.gte(field, value);
          break;
        case 'lte':
          query = query.lte(field, value);
          break;
        default:
          throw new Error(`Unsupported operator for update: ${operator}`);
      }
      
      // Add select clause to get returning data
      query = query.select(returning);
      
      const result = await query;
      const { data: updatedData, error } = result;
      
      if (error) {
        console.error('‚ùå Supabase UPDATE error:', error);
        throw new Error(`Failed to update ${table}: ${error.message}`);
      }
      
      console.log('‚úÖ Supabase UPDATE success:', { table, rowCount: updatedData?.length || 0 });
      
      return {
        table,
        data: updatedData || [],
        count: updatedData?.length || 0
      };
    } catch (error) {
      console.error('‚ùå Supabase UPDATE exception:', error);
      throw error;
    }
  }

  async supabaseDelete(params: any, userId: string): Promise<any> {
    const { table, filter } = params;
    
    console.log('üóëÔ∏è Supabase DELETE:', { table, filter, userId });
    
    if (!table) {
      throw new Error('Table name is required for supabase_delete');
    }
    
    if (!filter || !filter.field || !filter.operator || filter.value === undefined) {
      throw new Error('Filter with field, operator, and value is required for supabase_delete');
    }
    
    try {
      const { field, operator, value } = filter;
      
      let deleteQuery = supabase.from(table).delete();
      
      switch (operator) {
        case 'eq':
          deleteQuery = deleteQuery.eq(field, value);
          break;
        case 'neq':
          deleteQuery = deleteQuery.neq(field, value);
          break;
        case 'gt':
          deleteQuery = deleteQuery.gt(field, value);
          break;
        case 'lt':
          deleteQuery = deleteQuery.lt(field, value);
          break;
        case 'gte':
          deleteQuery = deleteQuery.gte(field, value);
          break;
        case 'lte':
          deleteQuery = deleteQuery.lte(field, value);
          break;
        default:
          throw new Error(`Unsupported operator for delete: ${operator}`);
      }
      
      const result = await deleteQuery;
      const { data, error } = result;
      
      if (error) {
        console.error('‚ùå Supabase DELETE error:', error);
        throw new Error(`Failed to delete from ${table}: ${error.message}`);
      }
      
      console.log('‚úÖ Supabase DELETE success:', { table, rowCount: data?.length || 0 });
      
      return {
        table,
        data: data || [],
        count: data?.length || 0
      };
    } catch (error) {
      console.error('‚ùå Supabase DELETE exception:', error);
      throw error;
    }
  }

  // MCP Protocol Functions
  async getConversationHistory(parameters: any, userId: string): Promise<any> {
    const { session_id, limit = 50, offset = 0 } = parameters;
    
    const { data: messages, error } = await supabase
      .from('messages')
      .select(`
        id,
        content,
        role,
        created_at,
        message_order,
        metadata,
        ai_metadata
      `)
      .eq('session_id', session_id)
      .order('message_order', { ascending: true })
      .range(offset, offset + limit - 1);
    
    if (error) {
      throw new Error(`Failed to retrieve messages: ${error.message}`);
    }
    
    return {
      session_id,
      messages: messages || [],
      total_retrieved: messages?.length || 0,
      offset,
      limit
    };
  }

  async getRecentSessions(parameters: any, userId: string): Promise<any> {
    const { limit = 10 } = parameters;
    
    const { data: sessions, error } = await supabase
      .from('sessions')
      .select(`
        id,
        title,
        description,
        created_at,
        updated_at,
        session_metadata
      `)
      .eq('user_id', userId)
      .eq('is_archived', false)
      .order('updated_at', { ascending: false })
      .limit(limit);
    
    if (error) {
      throw new Error(`Failed to retrieve sessions: ${error.message}`);
    }
    
    return {
      sessions: sessions || [],
      total_retrieved: sessions?.length || 0
    };
  }

  async storeMessage(parameters: any, userId: string): Promise<any> {
    const { session_id, content, role, metadata = {} } = parameters;
    
    // Get the current highest message order for this session
    const { data: lastMessage } = await supabase
      .from('messages')
      .select('message_order')
      .eq('session_id', session_id)
      .order('message_order', { ascending: false })
      .limit(1)
      .single();
    
    const nextOrder = (lastMessage?.message_order || 0) + 1;
    
    const { data: message, error } = await supabase
      .from('messages')
      .insert({
        session_id,
        user_id: userId,
        content,
        role,
        message_order: nextOrder,
        metadata
      })
      .select()
      .single();
    
    if (error) {
      throw new Error(`Failed to store message: ${error.message}`);
    }
    
    // Update session timestamp
    await supabase
      .from('sessions')
      .update({ updated_at: new Date().toISOString() })
      .eq('id', session_id);
    
    return {
      message_id: message.id,
      session_id,
      message_order: nextOrder,
      created_at: message.created_at
    };
  }

  async createSession(parameters: any, userId: string): Promise<any> {
    const { title, description } = parameters;
    
    const { data: session, error } = await supabase
      .from('sessions')
      .insert({
        user_id: userId,
        title,
        description
      })
      .select()
      .single();
    
    if (error) {
      throw new Error(`Failed to create session: ${error.message}`);
    }
    
    return {
      session_id: session.id,
      title: session.title,
      description: session.description,
      created_at: session.created_at
    };
  }

  async searchMessages(parameters: any, userId: string): Promise<any> {
    const { query, limit = 20 } = parameters;
    
    // Use text search across messages for sessions owned by this user
    const { data: messages, error } = await supabase
      .from('messages')
      .select(`
        id,
        session_id,
        content,
        role,
        created_at,
        sessions!inner(title, description)
      `)
      .textSearch('content', query)
      .eq('sessions.user_id', userId)
      .order('created_at', { ascending: false })
      .limit(limit);
    
    if (error) {
      throw new Error(`Failed to search messages: ${error.message}`);
    }
    
    return {
      query,
      results: messages || [],
      total_found: messages?.length || 0
    };
  }

  // Create and set RFP function - server-side implementation for performance
  async createAndSetRfp(params: any, userId: string, sessionContext?: { sessionId: string; timestamp: string }) {
    const startTime = Date.now();
    console.log('üîç DEBUG: createAndSetRfp called with params:', JSON.stringify(params, null, 2));
    console.log('üîç DEBUG: createAndSetRfp called with userId:', userId);
    
    // Robust parameter validation
    if (!params || typeof params !== 'object') {
      throw new Error('Invalid parameters provided to createAndSetRfp. Expected object with at least a name field.');
    }
    
    const { name, description = '', specification = '', due_date = null } = params;
    
    console.log('üöÄ Creating and setting new RFP:', { name, userId });
    
    if (!name || typeof name !== 'string' || name.trim() === '') {
      console.error('‚ùå DEBUG: Invalid name parameter:', { name, params });
      throw new Error(`RFP name is required and must be a non-empty string. Received: ${typeof name === 'string' ? `"${name}"` : typeof name}`);
    }
    
    try {
      // Step 1: Get the user profile and current session ID
      console.log('‚è±Ô∏è TIMING: Starting Step 1 - Get user profile and session at', Date.now() - startTime, 'ms');
      const { data: profile, error: profileError } = await supabase
        .from('user_profiles')
        .select('id, current_session_id')
        .eq('supabase_user_id', userId)
        .single();
      
      if (profileError || !profile) {
        throw new Error('User profile not found. Please ensure you are authenticated.');
      }
      
      let session_id = profile.current_session_id;
      
      // Step 1a: Use session context as fallback if available
      if (!session_id && sessionContext?.sessionId) {
        console.log('‚ö° Using session context as fallback:', sessionContext.sessionId);
        session_id = sessionContext.sessionId;
        
        // Verify this session exists and belongs to the user
        const { data: sessionCheck } = await supabase
          .from('sessions')
          .select('id')
          .eq('id', session_id)
          .eq('user_id', profile.id)
          .single();
        
        if (sessionCheck) {
          console.log('‚úÖ Session context verified, setting as current session');
          // Set as current session in user profile
          await supabase.rpc('set_user_current_session', {
            user_uuid: userId,
            session_uuid: session_id
          });
        } else {
          console.log('‚ö†Ô∏è Session context invalid, will create new session');
          session_id = null;
        }
      }
      
      // Step 1b: If still no current session, create one automatically
      if (!session_id) {
        console.log('‚ö†Ô∏è No current session found, creating new session automatically');
        console.log('‚è±Ô∏è TIMING: Starting Step 1a - Auto-create session at', Date.now() - startTime, 'ms');
        
        const { data: newSession, error: sessionError } = await supabase
          .from('sessions')
          .insert({
            user_id: profile.id,
            title: `RFP Session - ${name}`,
            description: 'Auto-created session for RFP creation'
          })
          .select()
          .single();
        
        if (sessionError) {
          throw new Error(`Failed to create session: ${sessionError.message}`);
        }
        
        session_id = newSession.id;
        console.log('‚úÖ New session created:', session_id);
        
        // Set as current session in user profile
        const { error: setSessionError } = await supabase
          .rpc('set_user_current_session', {
            user_uuid: userId,
            session_uuid: session_id
          });
        
        if (setSessionError) {
          console.warn('‚ö†Ô∏è Failed to set as current session, but continuing with RFP creation:', setSessionError);
        } else {
          console.log('‚úÖ Session set as current for user');
        }
        
        console.log('‚è±Ô∏è TIMING: Step 1a completed at', Date.now() - startTime, 'ms');
      } else {
        console.log('‚úÖ Found existing current session:', session_id);
      }
      
      console.log('‚è±Ô∏è TIMING: Step 1 completed at', Date.now() - startTime, 'ms');
      
      // Step 2: Verify session exists and check if it already has a current RFP
      console.log('‚è±Ô∏è TIMING: Starting Step 2 - Verify session at', Date.now() - startTime, 'ms');
      const { data: currentSession, error: sessionError } = await supabase
        .from('sessions')
        .select('id, current_rfp_id, user_id')
        .eq('id', session_id)
        .single();
      
      if (sessionError || !currentSession) {
        throw new Error('Session not found. Please ensure you have a valid session.');
      }
      
      if (currentSession.current_rfp_id) {
        console.log('‚ö†Ô∏è Session already has current RFP:', currentSession.current_rfp_id);
      }
      console.log('‚è±Ô∏è TIMING: Step 2 completed at', Date.now() - startTime, 'ms');
      
      // Step 3: Create new RFP with supabase_insert
      console.log('‚è±Ô∏è TIMING: Starting Step 3 - Create RFP at', Date.now() - startTime, 'ms');
      
      // ‚úÖ FIX: Provide required fields that match database schema
      // Database schema requires: name, due_date, description, specification as NOT NULL
      const defaultDueDate = new Date();
      defaultDueDate.setDate(defaultDueDate.getDate() + 30); // Default 30 days from now
      
      const insertData: {
        name: string;
        description: string;
        specification: string;
        due_date: string;
      } = {
        name: name.trim(),
        description: description && description.trim() ? description.trim() : 'RFP created via AI assistant. Details to be filled in.',
        specification: specification && specification.trim() ? specification.trim() : 'Specification details to be provided.',
        due_date: due_date || defaultDueDate.toISOString().split('T')[0] // YYYY-MM-DD format
      };
      
      const { data: newRfp, error: insertError } = await supabase
        .from('rfps')
        .insert(insertData)
        .select('id, name, description, specification, due_date, created_at')
        .single();
      
      if (insertError) {
        console.error('‚ùå Failed to create RFP:', insertError);
        throw new Error(`Failed to create RFP: ${insertError.message}`);
      }
      
      console.log('‚úÖ RFP created successfully:', newRfp.id);
      console.log('‚è±Ô∏è TIMING: Step 3 completed at', Date.now() - startTime, 'ms');
      
      // Step 4: Set as current RFP for the session
      console.log('‚è±Ô∏è TIMING: Starting Step 4 - Set as current RFP at', Date.now() - startTime, 'ms');
      const { error: updateError } = await supabase
        .from('sessions')
        .update({ current_rfp_id: newRfp.id })
        .eq('id', session_id)
        .select('id, current_rfp_id')
        .single();
      
      if (updateError) {
        console.error('‚ùå Failed to set as current RFP:', updateError);
        throw new Error(`RFP created but failed to set as current: ${updateError.message}`);
      }
      
      console.log('‚úÖ RFP set as current for session successfully');
      console.log('‚è±Ô∏è TIMING: Step 4 completed at', Date.now() - startTime, 'ms');
      
      // Step 5: Validation - verify RFP exists in database
      console.log('‚è±Ô∏è TIMING: Starting Step 5 - Validate creation at', Date.now() - startTime, 'ms');
      const { data: verifyRfp, error: verifyError } = await supabase
        .from('rfps')
        .select('id, name, description')
        .eq('id', newRfp.id)
        .single();
      
      if (verifyError || !verifyRfp) {
        throw new Error('RFP creation validation failed - RFP not found after creation');
      }
      
      console.log('‚úÖ RFP creation validated successfully');
      console.log('‚è±Ô∏è TIMING: Step 5 completed at', Date.now() - startTime, 'ms');
      console.log('‚è±Ô∏è TIMING: Total execution time:', Date.now() - startTime, 'ms');
      
      const wasSessionCreated = !profile.current_session_id;
      const sessionMessage = wasSessionCreated ? ' (session auto-created)' : '';
      
      return {
        success: true,
        rfp: newRfp,
        current_rfp_id: newRfp.id,
        session_id: session_id,
        session_auto_created: wasSessionCreated,
        message: `RFP "${newRfp.name}" created successfully and set as current RFP${sessionMessage}`,
        steps_completed: [
          'retrieved_user_profile',
          ...(wasSessionCreated ? ['auto_created_session', 'set_as_current_session'] : ['found_existing_session']),
          'verified_session_exists',
          'created_rfp_record', 
          'set_as_current_rfp_for_session',
          'validated_creation'
        ]
      };
      
    } catch (error) {
      console.error('‚ùå Error in createAndSetRfp:', error);
      throw error;
    }
  }

  // Agent management functions
  async getAvailableAgents(parameters: any, userId: string): Promise<any> {
    try {
      const { data: agents, error } = await supabase
        .from('agents')
        .select('id, name, role, instructions, access_level, is_active')
        .eq('is_active', true)
        .order('name');
      
      if (error) {
        throw new Error(`Failed to get available agents: ${error.message}`);
      }
      
      return {
        success: true,
        agents: agents || [],
        count: agents?.length || 0
      };
    } catch (error) {
      console.error('‚ùå Error getting available agents:', error);
      throw error;
    }
  }

  async getCurrentAgent(parameters: any, userId: string): Promise<any> {
    const { session_id } = parameters;
    
    try {
      // Get current agent for the session
      const { data: sessionAgent, error } = await supabase
        .from('session_agents')
        .select(`
          agent_id,
          agents!inner(id, name, role, instructions)
        `)
        .eq('session_id', session_id)
        .eq('is_active', true)
        .single();
      
      if (error && error.code !== 'PGRST116') { // PGRST116 is "not found"
        throw new Error(`Failed to get current agent: ${error.message}`);
      }
      
      return {
        success: true,
        current_agent: sessionAgent?.agents || null,
        agent_id: sessionAgent?.agent_id || null
      };
    } catch (error) {
      console.error('‚ùå Error getting current agent:', error);
      throw error;
    }
  }

  async switchAgent(parameters: any, userId: string): Promise<any> {
    const { session_id, agent_id } = parameters;
    
    if (!session_id || !agent_id) {
      throw new Error('Both session_id and agent_id are required for switch_agent');
    }
    
    try {
      // Verify the agent exists and is active
      const { data: agent, error: agentError } = await supabase
        .from('agents')
        .select('id, name, role, instructions')
        .eq('id', agent_id)
        .eq('is_active', true)
        .single();
      
      if (agentError) {
        throw new Error(`Agent not found or inactive: ${agentError.message}`);
      }
      
      // Deactivate current agent for this session
      await supabase
        .from('session_agents')
        .update({ is_active: false })
        .eq('session_id', session_id)
        .eq('is_active', true);
      
      // Activate new agent for this session
      const { data: sessionAgent, error: insertError } = await supabase
        .from('session_agents')
        .insert({
          session_id,
          agent_id,
          is_active: true
        })
        .select()
        .single();
      
      if (insertError) {
        throw new Error(`Failed to switch agent: ${insertError.message}`);
      }
      
      return {
        success: true,
        new_agent: agent,
        session_agent_id: sessionAgent.id,
        message: `Successfully switched to ${agent.name} agent`
      };
    } catch (error) {
      console.error('‚ùå Error switching agent:', error);
      throw error;
    }
  }

  async recommendAgent(parameters: any, userId: string): Promise<any> {
    const { context, task_type } = parameters;
    
    try {
      // Simple recommendation logic based on task type
      let recommendedRole = 'Solutions'; // Default
      
      if (task_type) {
        if (task_type.includes('design') || task_type.includes('create')) {
          recommendedRole = 'RFP Design';
        } else if (task_type.includes('technical') || task_type.includes('spec')) {
          recommendedRole = 'Technical Support';
        } else if (task_type.includes('bid') || task_type.includes('proposal')) {
          recommendedRole = 'RFP Assistant';
        }
      }
      
      const { data: agent, error } = await supabase
        .from('agents')
        .select('id, name, role, instructions')
        .eq('role', recommendedRole)
        .eq('is_active', true)
        .single();
      
      if (error) {
        // Fallback to Solutions agent
        const { data: fallbackAgent } = await supabase
          .from('agents')
          .select('id, name, role, instructions')
          .eq('role', 'Solutions')
          .eq('is_active', true)
          .single();
        
        return {
          success: true,
          recommended_agent: fallbackAgent,
          reason: 'Default recommendation (Solutions agent)'
        };
      }
      
      return {
        success: true,
        recommended_agent: agent,
        reason: `Recommended based on task type: ${task_type}`
      };
    } catch (error) {
      console.error('‚ùå Error recommending agent:', error);
      throw error;
    }
  }

  // Artifact management functions
  async createFormArtifact(parameters: any, userId: string): Promise<any> {
    const { title, content, form_schema, session_id } = parameters;
    
    try {
      const { data: artifact, error } = await supabase
        .from('form_artifacts')
        .insert({
          title,
          content,
          form_schema,
          session_id,
          user_id: userId,
          type: 'form'
        })
        .select()
        .single();
      
      if (error) {
        throw new Error(`Failed to create form artifact: ${error.message}`);
      }
      
      return {
        success: true,
        artifact_id: artifact.id,
        artifact,
        message: `Form artifact "${title}" created successfully`
      };
    } catch (error) {
      console.error('‚ùå Error creating form artifact:', error);
      throw error;
    }
  }

  async createTextArtifact(parameters: any, userId: string): Promise<any> {
    const { title, content, session_id } = parameters;
    
    try {
      const { data: artifact, error } = await supabase
        .from('artifacts')
        .insert({
          title,
          content,
          session_id,
          user_id: userId,
          type: 'text'
        })
        .select()
        .single();
      
      if (error) {
        throw new Error(`Failed to create text artifact: ${error.message}`);
      }
      
      return {
        success: true,
        artifact_id: artifact.id,
        artifact,
        message: `Text artifact "${title}" created successfully`
      };
    } catch (error) {
      console.error('‚ùå Error creating text artifact:', error);
      throw error;
    }
  }

  async generateRequestArtifact(parameters: any, userId: string): Promise<any> {
    const { rfp_id, session_id } = parameters;
    
    try {
      // Get RFP details
      const { data: rfp, error: rfpError } = await supabase
        .from('rfps')
        .select('*')
        .eq('id', rfp_id)
        .single();
      
      if (rfpError) {
        throw new Error(`Failed to get RFP: ${rfpError.message}`);
      }
      
      // Generate request content based on RFP
      const requestContent = {
        rfp_name: rfp.name,
        description: rfp.description,
        specification: rfp.specification,
        due_date: rfp.due_date,
        generated_at: new Date().toISOString()
      };
      
      const { data: artifact, error } = await supabase
        .from('artifacts')
        .insert({
          title: `Request for ${rfp.name}`,
          content: JSON.stringify(requestContent),
          session_id,
          user_id: userId,
          type: 'request',
          rfp_id
        })
        .select()
        .single();
      
      if (error) {
        throw new Error(`Failed to create request artifact: ${error.message}`);
      }
      
      return {
        success: true,
        artifact_id: artifact.id,
        artifact,
        rfp,
        message: `Request artifact generated for "${rfp.name}"`
      };
    } catch (error) {
      console.error('‚ùå Error generating request artifact:', error);
      throw error;
    }
  }

  async updateFormArtifact(parameters: any, userId: string): Promise<any> {
    const { artifact_id, content, form_schema } = parameters;
    
    try {
      const updateData: any = {};
      if (content !== undefined) updateData.content = content;
      if (form_schema !== undefined) updateData.form_schema = form_schema;
      
      const { data: artifact, error } = await supabase
        .from('form_artifacts')
        .update(updateData)
        .eq('id', artifact_id)
        .eq('user_id', userId)
        .select()
        .single();
      
      if (error) {
        throw new Error(`Failed to update form artifact: ${error.message}`);
      }
      
      return {
        success: true,
        artifact_id,
        artifact,
        message: 'Form artifact updated successfully'
      };
    } catch (error) {
      console.error('‚ùå Error updating form artifact:', error);
      throw error;
    }
  }

  async getFormSubmission(parameters: any, userId: string): Promise<any> {
    const { artifact_id } = parameters;
    
    try {
      const { data: submissions, error } = await supabase
        .from('form_submissions')
        .select('*')
        .eq('artifact_id', artifact_id)
        .order('created_at', { ascending: false });
      
      if (error) {
        throw new Error(`Failed to get form submissions: ${error.message}`);
      }
      
      return {
        success: true,
        submissions: submissions || [],
        count: submissions?.length || 0
      };
    } catch (error) {
      console.error('‚ùå Error getting form submissions:', error);
      throw error;
    }
  }

  async validateFormData(parameters: any, userId: string): Promise<any> {
    const { form_data, form_schema } = parameters;
    
    try {
      // Basic validation - in a real implementation, you'd use a schema validator
      const errors: string[] = [];
      
      if (!form_data || typeof form_data !== 'object') {
        errors.push('Form data must be an object');
      }
      
      if (!form_schema || typeof form_schema !== 'object') {
        errors.push('Form schema must be an object');
      }
      
      return {
        success: errors.length === 0,
        valid: errors.length === 0,
        errors,
        message: errors.length === 0 ? 'Form data is valid' : `Validation failed: ${errors.join(', ')}`
      };
    } catch (error) {
      console.error('‚ùå Error validating form data:', error);
      throw error;
    }
  }

  async createArtifactTemplate(parameters: any, userId: string): Promise<any> {
    const { name, template_schema, description } = parameters;
    
    try {
      const { data: template, error } = await supabase
        .from('artifact_templates')
        .insert({
          name,
          template_schema,
          description,
          created_by: userId
        })
        .select()
        .single();
      
      if (error) {
        throw new Error(`Failed to create artifact template: ${error.message}`);
      }
      
      return {
        success: true,
        template_id: template.id,
        template,
        message: `Artifact template "${name}" created successfully`
      };
    } catch (error) {
      console.error('‚ùå Error creating artifact template:', error);
      throw error;
    }
  }

  async listArtifactTemplates(parameters: any, userId: string): Promise<any> {
    try {
      const { data: templates, error } = await supabase
        .from('artifact_templates')
        .select('id, name, description, created_at')
        .eq('is_active', true)
        .order('name');
      
      if (error) {
        throw new Error(`Failed to list artifact templates: ${error.message}`);
      }
      
      return {
        success: true,
        templates: templates || [],
        count: templates?.length || 0
      };
    } catch (error) {
      console.error('‚ùå Error listing artifact templates:', error);
      throw error;
    }
  }

  // RFP management functions
  async setCurrentRfp(parameters: any, userId: string): Promise<any> {
    const { session_id, rfp_id } = parameters;
    
    try {
      const { data: session, error } = await supabase
        .from('sessions')
        .update({ current_rfp_id: rfp_id })
        .eq('id', session_id)
        .select('id, current_rfp_id')
        .single();
      
      if (error) {
        throw new Error(`Failed to set current RFP: ${error.message}`);
      }
      
      return {
        success: true,
        current_rfp_id: rfp_id,
        session_id,
        message: 'Current RFP set successfully'
      };
    } catch (error) {
      console.error('‚ùå Error setting current RFP:', error);
      throw error;
    }
  }

  async refreshCurrentRfp(parameters: any, userId: string): Promise<any> {
    const { session_id } = parameters;
    
    try {
      const { data: session, error } = await supabase
        .from('sessions')
        .select('current_rfp_id, rfps(*)')
        .eq('id', session_id)
        .single();
      
      if (error) {
        throw new Error(`Failed to refresh current RFP: ${error.message}`);
      }
      
      return {
        success: true,
        current_rfp: session.rfps,
        current_rfp_id: session.current_rfp_id,
        message: 'Current RFP refreshed successfully'
      };
    } catch (error) {
      console.error('‚ùå Error refreshing current RFP:', error);
      throw error;
    }
  }

  async getArtifactStatus(parameters: any, userId: string): Promise<any> {
    const { artifact_id } = parameters;
    
    try {
      const { data: artifact, error } = await supabase
        .from('artifacts')
        .select('id, title, type, created_at, updated_at')
        .eq('id', artifact_id)
        .eq('user_id', userId)
        .single();
      
      if (error) {
        throw new Error(`Failed to get artifact status: ${error.message}`);
      }
      
      return {
        success: true,
        artifact,
        status: 'active',
        message: 'Artifact status retrieved successfully'
      };
    } catch (error) {
      console.error('‚ùå Error getting artifact status:', error);
      throw error;
    }
  }

  async generateRfpBidUrl(parameters: any, userId: string): Promise<any> {
    const { rfp_id } = parameters;
    
    try {
      // In a real implementation, this would generate a secure URL
      const bidUrl = `https://rfpez.ai/bid/${rfp_id}`;
      
      return {
        success: true,
        rfp_id,
        bid_url: bidUrl,
        message: 'RFP bid URL generated successfully'
      };
    } catch (error) {
      console.error('‚ùå Error generating RFP bid URL:', error);
      throw error;
    }
  }
}

// Client callback generator
function generateClientCallbacks(functionName: string, result: any, params?: any): ClientCallback[] {
  const callbacks: ClientCallback[] = [];
  
  console.log(`üîÑ DEBUG - Generating callbacks for ${functionName}:`, {
    functionName,
    resultSuccess: result?.success,
    resultKeys: result ? Object.keys(result) : 'none',
    paramsKeys: params ? Object.keys(params) : 'none'
  });
  
  switch (functionName) {
    case 'set_current_rfp':
      if (result.success && result.current_rfp_id) {
        callbacks.push({
          type: 'ui_refresh',
          target: 'rfp_context',
          payload: { 
            rfp_id: result.current_rfp_id,
            message: result.message 
          }
        });
      }
      break;
      
    case 'refresh_current_rfp':
      callbacks.push({
        type: 'ui_refresh',
        target: 'rfp_context',
        payload: { message: 'RFP context refresh requested' }
      });
      break;
      
    case 'create_and_set_rfp':
      if (result.success && result.current_rfp_id) {
        callbacks.push({
          type: 'ui_refresh',
          target: 'rfp_context',
          payload: { 
            rfp_id: result.current_rfp_id,
            rfp_name: result.rfp?.name,
            rfp_data: result.rfp, // Include full RFP data to avoid database re-query
            message: result.message 
          }
        });
      }
      break;
      
    case 'create_form_artifact':
      if (result.success && result.artifact_id) {
        callbacks.push({
          type: 'ui_refresh',
          target: 'artifact_viewer',
          payload: { 
            artifactId: result.artifact_id,
            type: 'form',
            content: result
          }
        });
      }
      break;
      
    case 'update_form_artifact':
      if (result.success && result.artifact_id) {
        callbacks.push({
          type: 'ui_refresh',
          target: 'artifact_viewer',
          payload: { 
            artifactId: result.artifact_id,
            type: 'form',
            content: result.content
          }
        });
      }
      break;
      
    case 'switch_agent':
      if (result.success && result.new_agent) {
        callbacks.push({
          type: 'state_update',
          target: 'agent_context',
          payload: {
            agent_id: result.new_agent.id,
            agent_name: result.new_agent.name,
            message: result.message
          }
        });
      }
      break;
  }
  
  console.log(`üì§ DEBUG - Generated callbacks:`, {
    functionName,
    callbackCount: callbacks.length,
    callbacks: callbacks.map(cb => ({
      type: cb.type,
      target: cb.target,
      payloadKeys: cb.payload ? Object.keys(cb.payload) : 'none'
    }))
  });
  
  return callbacks;
}

// Main function handler
async function handleFunction(functionCall: EdgeFunctionCall, userId: string): Promise<EdgeFunctionResponse> {
  const { functionName, parameters, sessionContext } = functionCall;
  
  console.log(`üöÄ Handling function: ${functionName}`, { 
    userId, 
    parameters,
    sessionContext: sessionContext ? { sessionId: sessionContext.sessionId } : 'none'
  });
  
  console.log(`üìä DEBUG - Function call details:`, {
    functionName,
    parameterKeys: parameters ? Object.keys(parameters) : 'none',
    parametersSize: parameters ? JSON.stringify(parameters).length : 0,
    hasSessionContext: !!sessionContext
  });
  
  const claudeHandler = new ClaudeAPIHandler();
  const dbHandler = new DatabaseHandler();
  
  try {
    let result: any;
    
    // Route function calls
    switch (functionName) {
      // Claude API functions
      case 'generate_message':
        result = await claudeHandler.generateMessage(parameters);
        break;
        
      case 'test_connection':
        result = await claudeHandler.testConnection();
        break;
        
      // Database operations
      case 'supabase_select':
        result = await dbHandler.supabaseSelect(parameters, userId);
        break;
        
      case 'supabase_insert':
        result = await dbHandler.supabaseInsert(parameters, userId);
        break;
        
      case 'supabase_update':
        result = await dbHandler.supabaseUpdate(parameters, userId);
        break;
        
      case 'supabase_delete':
        result = await dbHandler.supabaseDelete(parameters, userId);
        break;
        
      case 'create_and_set_rfp':
        result = await dbHandler.createAndSetRfp(parameters, userId, sessionContext);
        break;
        
      // MCP Protocol functions
      case 'get_conversation_history':
        result = await dbHandler.getConversationHistory(parameters, userId);
        break;
        
      case 'get_recent_sessions':
        result = await dbHandler.getRecentSessions(parameters, userId);
        break;
        
      case 'store_message':
        result = await dbHandler.storeMessage(parameters, userId);
        break;
        
      case 'create_session':
        result = await dbHandler.createSession(parameters, userId);
        break;
        
      case 'search_messages':
        result = await dbHandler.searchMessages(parameters, userId);
        break;
        
      // Agent management functions
      case 'get_available_agents':
        result = await dbHandler.getAvailableAgents(parameters, userId);
        break;
        
      case 'get_current_agent':
        result = await dbHandler.getCurrentAgent(parameters, userId);
        break;
        
      case 'switch_agent':
        result = await dbHandler.switchAgent(parameters, userId);
        break;
        
      case 'recommend_agent':
        result = await dbHandler.recommendAgent(parameters, userId);
        break;
        
      // Artifact management functions
      case 'create_form_artifact':
        result = await dbHandler.createFormArtifact(parameters, userId);
        break;
        
      case 'create_text_artifact':
        result = await dbHandler.createTextArtifact(parameters, userId);
        break;
        
      case 'generate_request_artifact':
        result = await dbHandler.generateRequestArtifact(parameters, userId);
        break;
        
      case 'update_form_artifact':
        result = await dbHandler.updateFormArtifact(parameters, userId);
        break;
        
      case 'get_form_submission':
        result = await dbHandler.getFormSubmission(parameters, userId);
        break;
        
      case 'validate_form_data':
        result = await dbHandler.validateFormData(parameters, userId);
        break;
        
      case 'create_artifact_template':
        result = await dbHandler.createArtifactTemplate(parameters, userId);
        break;
        
      case 'list_artifact_templates':
        result = await dbHandler.listArtifactTemplates(parameters, userId);
        break;
        
      // RFP management functions
      case 'set_current_rfp':
        result = await dbHandler.setCurrentRfp(parameters, userId);
        break;
        
      case 'refresh_current_rfp':
        result = await dbHandler.refreshCurrentRfp(parameters, userId);
        break;
        
      case 'get_artifact_status':
        result = await dbHandler.getArtifactStatus(parameters, userId);
        break;
        
      case 'generate_rfp_bid_url':
        result = await dbHandler.generateRfpBidUrl(parameters, userId);
        break;
        
      default:
        throw new Error(`Unknown function: ${functionName}`);
    }
    
    // Generate client callbacks
    const clientCallbacks = generateClientCallbacks(functionName, result, parameters);
    
    console.log(`üì§ DEBUG - Response generation:`, {
      functionName,
      resultSuccess: result?.success,
      resultDataKeys: result?.data ? Object.keys(result.data) : 'none',
      callbackCount: clientCallbacks.length,
      callbacks: clientCallbacks,
      requiresClientAction: clientCallbacks.length > 0
    });
    
    const response = {
      success: true,
      data: result,
      clientCallbacks,
      requiresClientAction: clientCallbacks.length > 0,
      message: `Function ${functionName} executed successfully`
    };
    
    console.log(`üìã DEBUG - Final response:`, {
      responseSuccess: response.success,
      responseDataExists: !!response.data,
      responseCallbackCount: response.clientCallbacks?.length || 0,
      responseSize: JSON.stringify(response).length
    });
    
    return response;
    
  } catch (error) {
    console.error(`‚ùå Error handling function ${functionName}:`, error);
    
    return {
      success: false,
      data: null,
      clientCallbacks: [],
      requiresClientAction: false,
      message: `Error executing ${functionName}: ${error instanceof Error ? error.message : String(error)}`
    };
  }
}

// HTTP handler
serve(async (req: Request) => {
  // Handle CORS
  if (req.method === 'OPTIONS') {
    return new Response(null, {
      status: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
        'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type, cache-control',
      },
    });
  }

  if (req.method !== 'POST') {
    return new Response(JSON.stringify({ error: 'Method not allowed' }), {
      status: 405,
      headers: { 'Content-Type': 'application/json' },
    });
  }

  try {
    // Parse request body
    const body = await req.json();
    const { functionName, parameters, stream, sessionContext } = body;
    
    if (!functionName) {
      return new Response(JSON.stringify({ 
        success: false,
        error: 'functionName is required' 
      }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // Get user from auth header
    const authResult = await getUserFromAuth(req.headers.get('authorization'));
    const userId = authResult?.user?.id || 'anonymous';
    
    console.log(`üîë User ID: ${userId}, Function: ${functionName}, Stream: ${stream}`);

    // Handle streaming requests for Claude API calls
    if (stream && functionName === 'generate_response') {
      console.log('üåä Handling streaming Claude API request');
      
      const claudeHandler = new ClaudeAPIHandler();
      // Add sessionContext and userId to parameters for streaming
      const streamingParams = {
        ...parameters,
        sessionContext: sessionContext,
        userId: userId
      };
      const streamResponse = await claudeHandler.generateStreamingResponse(streamingParams);
      
      return new Response(streamResponse, {
        status: 200,
        headers: {
          'Content-Type': 'text/event-stream',
          'Cache-Control': 'no-cache',
          'Connection': 'keep-alive',
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type, cache-control',
        },
      });
    }

    // Handle regular function calls
    const response = await handleFunction({ functionName, parameters, sessionContext }, userId);

    console.log(`üåê DEBUG - Sending HTTP response:`, {
      functionName,
      responseSuccess: response.success,
      responseStatus: response.success ? 200 : 400,
      responseCallbacks: response.clientCallbacks?.length || 0,
      responseSize: JSON.stringify(response).length,
      hasData: !!response.data
    });

    return new Response(JSON.stringify(response), {
      status: response.success ? 200 : 400,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type, cache-control',
      },
    });

  } catch (error) {
    console.error('‚ùå Edge function error:', error);
    
    return new Response(JSON.stringify({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      data: null,
    }), {
      status: 500,
      headers: { 
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type, cache-control',
      },
    });
  }
});

console.log('üöÄ Claude API Edge Function v2 is running');